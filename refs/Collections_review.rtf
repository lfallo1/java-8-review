{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf130
{\fonttbl\f0\fnil\fcharset0 Georgia;}
{\colortbl;\red255\green255\blue255;\red63\green95\blue191;\red127\green127\blue159;\red29\green29\blue29;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww20580\viewh7960\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf0 \
\cf2 		 * ArrayList \cf3 -\cf2  implemented as \ul resizeable\ulnone  array. As more elements are added to ArrayList, its size is increased dynamically. FASTER for get/set operations It's elements can be accessed directly by using the get and set methods, since ArrayList is essentially an array\cf0 \
\cf2 		 * Vector \cf3 -\cf2  thread\cf3 -\cf2 safe version of array list (requires more memory)\cf0 \
\cf2 		 * LinkedList \cf3 -\cf2  implemented as doubly linked list. faster for insertions and deletions, then ArrayList/Vector. slow for get/set operations.\
\

\b \ul ArrayList vs LinkedList Performance
\b0 \ulnone \
\cf4 \expnd0\expndtw0\kerning0
LinkedList is faster in add and remove, but slower in get. Based on the complexity table and testing results, we can figure out when to use ArrayList or LinkedList.\'a0\
In brief, LinkedList should be preferred if:\'a0\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf4 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
there are no large number of random access of element\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
there are a large number of add/remove operations\
\pard\pardeftab720\partightenfactor0
\cf2 \kerning1\expnd0\expndtw0 \
\cf0 \
\cf2 		 * HashSet \cf3 --\cf2  unordered, no \ul dups\cf0 \ulnone \
\cf2 		 * LinkedHashSet \cf3 --\cf2  ordered by insertion, no \ul dups\cf0 \ulnone \
\cf2 		 * TreeSet \cf3 --\cf2  ordered by sorting \ul criterea\ulnone , no \ul dups\cf0 \ulnone \
\
\cf2 		 * HashMap \cf3 -\cf2  k/v, no \ul dups\ulnone  by key (according to \ul hashcode\ulnone  & equals), order not guaranteed\cf0 \
\cf2 		 * HashTable \cf3 -\cf2  \ul ike\ulnone  \ul hashmap\ulnone , but synchronous (overhead, only use if not \ul threadsafe\ulnone )\cf0 \
\cf2 		 * LinkedHashMap \cf3 -\cf2  k/v, no \ul dups\ulnone  by key, insertion order preserved\cf0 \
\cf2 		 * TreeMap \cf3 -\cf2  k/v, no \ul dups\ulnone  by key, sorted (key object must be \ul sortable\ulnone , or implement comparable)\cf0 \
\
\cf2 		 * Comparable \cf3 -\cf2  the interface a class must implement if it wishes to define its own sorting\cf0 \
\cf2 		 * Comparator \cf3 -\cf2  A class that can be used to sort an object. the object being sorted does not need to define its own sorting\cf0 \
\cf2 		 * 		can be defined in its own class or as an anonymous class (either in line or even declared as a constant)\cf0 \
}